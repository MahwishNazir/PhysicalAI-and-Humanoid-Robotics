#!/usr/bin/env python3
"""
Action Executor for Robot Task Plans

This module executes action sequences generated by the LLM planner using
ROS 2 action clients. It handles sequential execution with progress tracking,
status reporting, and integration with navigation and manipulation stacks.

Features:
- Sequential action execution
- Progress tracking and callbacks
- ROS 2 action client integration
- Status reporting and logging
- Graceful cancellation support

Usage:
    from action_executor import ActionExecutor

    executor = ActionExecutor()
    result = executor.execute_plan(plan)
"""

import time
from typing import Dict, List, Optional, Callable
from dataclasses import dataclass
from enum import Enum
import threading

import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from rclpy.callback_groups import ReentrantCallbackGroup

# ROS 2 message types
from geometry_msgs.msg import PoseStamped, Twist
from std_msgs.msg import String

# For Nav2 integration (optional)
try:
    from nav2_msgs.action import NavigateToPose
    NAV2_AVAILABLE = True
except ImportError:
    NAV2_AVAILABLE = False


class ExecutionStatus(Enum):
    """Action execution status."""
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"


@dataclass
class ActionResult:
    """Result of an action execution."""
    action_type: str
    status: ExecutionStatus
    message: str
    duration: float  # actual execution time
    output: Optional[Dict] = None


class ActionExecutor(Node):
    """Executes robot action sequences from LLM-generated plans."""

    def __init__(self):
        super().__init__('action_executor')

        # Callback group for concurrent operations
        self.callback_group = ReentrantCallbackGroup()

        # Publishers for simple commands
        self.cmd_vel_pub = self.create_publisher(Twist, '/cmd_vel', 10)
        self.speech_pub = self.create_publisher(String, '/speech_output', 10)
        self.status_pub = self.create_publisher(String, '/execution_status', 10)

        # Action clients (initialized lazily)
        self._nav_client = None
        self._manipulation_client = None

        # Execution state
        self.current_plan = None
        self.current_step = 0
        self.is_executing = False
        self.cancel_requested = False

        # Progress callback
        self.progress_callback: Optional[Callable] = None

        # Action handlers mapping
        self.action_handlers = {
            'navigate': self._execute_navigate,
            'detect': self._execute_detect,
            'grasp': self._execute_grasp,
            'place': self._execute_place,
            'speak': self._execute_speak,
            'wait': self._execute_wait,
            'scan': self._execute_scan,
        }

        self.get_logger().info("Action executor initialized")

    def set_progress_callback(self, callback: Callable):
        """Set callback for progress updates.

        Args:
            callback: Function(step, total, status, message)
        """
        self.progress_callback = callback

    def _report_progress(self, step: int, total: int, status: str, message: str):
        """Report execution progress."""
        if self.progress_callback:
            self.progress_callback(step, total, status, message)

        # Publish status
        status_msg = String()
        status_msg.data = f"Step {step}/{total}: {status} - {message}"
        self.status_pub.publish(status_msg)

        self.get_logger().info(status_msg.data)

    def execute_plan(self, plan: Dict) -> List[ActionResult]:
        """Execute a complete action plan.

        Args:
            plan: Plan dictionary from LLMPlanner

        Returns:
            List of ActionResult for each step
        """
        if self.is_executing:
            self.get_logger().warn("Already executing a plan")
            return []

        self.is_executing = True
        self.cancel_requested = False
        self.current_plan = plan
        results = []

        actions = plan.get('plan', [])
        total_steps = len(actions)

        self._report_progress(0, total_steps, "STARTED", f"Executing: {plan.get('goal', 'Unknown')}")

        for i, action in enumerate(actions):
            if self.cancel_requested:
                self.get_logger().info("Execution cancelled")
                results.append(ActionResult(
                    action_type=action['type'],
                    status=ExecutionStatus.CANCELLED,
                    message="Cancelled by user",
                    duration=0.0
                ))
                break

            step = i + 1
            action_type = action['type']

            self._report_progress(step, total_steps, "IN_PROGRESS",
                                 action.get('description', action_type))

            # Execute the action
            start_time = time.time()
            result = self._execute_action(action)
            duration = time.time() - start_time
            result.duration = duration

            results.append(result)

            if result.status == ExecutionStatus.FAILED:
                self._report_progress(step, total_steps, "FAILED", result.message)
                break
            else:
                self._report_progress(step, total_steps, "COMPLETED",
                                     f"{action_type} completed in {duration:.1f}s")

        self.is_executing = False
        self.current_plan = None

        # Final status
        all_completed = all(r.status == ExecutionStatus.COMPLETED for r in results)
        final_status = "SUCCESS" if all_completed else "FAILED"
        self._report_progress(total_steps, total_steps, final_status,
                             f"Plan execution {'completed' if all_completed else 'failed'}")

        return results

    def _execute_action(self, action: Dict) -> ActionResult:
        """Execute a single action.

        Args:
            action: Action dictionary from plan

        Returns:
            ActionResult with execution status
        """
        action_type = action.get('type', 'unknown')
        handler = self.action_handlers.get(action_type)

        if handler is None:
            return ActionResult(
                action_type=action_type,
                status=ExecutionStatus.FAILED,
                message=f"Unknown action type: {action_type}",
                duration=0.0
            )

        try:
            return handler(action)
        except Exception as e:
            return ActionResult(
                action_type=action_type,
                status=ExecutionStatus.FAILED,
                message=f"Exception: {str(e)}",
                duration=0.0
            )

    def _execute_navigate(self, action: Dict) -> ActionResult:
        """Execute navigation action."""
        target = action.get('target', 'unknown')
        params = action.get('parameters', {})

        self.get_logger().info(f"Navigating to: {target}")

        # In a real system, this would use Nav2 action client
        # For demo, we simulate with a delay
        if NAV2_AVAILABLE and self._nav_client:
            # Real Nav2 implementation would go here
            pass

        # Simulate navigation with velocity commands
        twist = Twist()
        twist.linear.x = 0.3  # Move forward slowly
        self.cmd_vel_pub.publish(twist)

        # Simulate travel time based on estimated duration
        estimated = action.get('estimated_duration', 5.0)
        time.sleep(min(estimated, 2.0))  # Cap at 2s for demo

        # Stop
        twist = Twist()
        self.cmd_vel_pub.publish(twist)

        return ActionResult(
            action_type='navigate',
            status=ExecutionStatus.COMPLETED,
            message=f"Arrived at {target}",
            duration=0.0,
            output={'location': target}
        )

    def _execute_detect(self, action: Dict) -> ActionResult:
        """Execute object detection action."""
        target = action.get('target', 'object')
        params = action.get('parameters', {})

        self.get_logger().info(f"Detecting: {target}")

        # In a real system, this would call vision service
        # For demo, simulate detection
        time.sleep(1.0)  # Simulate processing

        # Simulate successful detection
        detected_position = {
            'x': 1.0,
            'y': 0.5,
            'z': 0.8,
            'confidence': 0.95
        }

        return ActionResult(
            action_type='detect',
            status=ExecutionStatus.COMPLETED,
            message=f"Detected {target}",
            duration=0.0,
            output={'position': detected_position, 'object': target}
        )

    def _execute_grasp(self, action: Dict) -> ActionResult:
        """Execute grasp action."""
        target = action.get('target', 'object')
        params = action.get('parameters', {})
        gripper_force = params.get('gripper_force', 0.5)

        self.get_logger().info(f"Grasping: {target} (force: {gripper_force})")

        # In a real system, this would use MoveIt2 for manipulation
        # For demo, simulate grasping
        time.sleep(2.0)  # Simulate gripper motion

        return ActionResult(
            action_type='grasp',
            status=ExecutionStatus.COMPLETED,
            message=f"Grasped {target}",
            duration=0.0,
            output={'object': target, 'gripper_force': gripper_force}
        )

    def _execute_place(self, action: Dict) -> ActionResult:
        """Execute place action."""
        target = action.get('target', 'location')
        params = action.get('parameters', {})

        self.get_logger().info(f"Placing at: {target}")

        # Simulate placing
        time.sleep(1.5)

        return ActionResult(
            action_type='place',
            status=ExecutionStatus.COMPLETED,
            message=f"Placed at {target}",
            duration=0.0,
            output={'location': target}
        )

    def _execute_speak(self, action: Dict) -> ActionResult:
        """Execute speak action."""
        params = action.get('parameters', {})
        message = params.get('message', 'Hello')

        self.get_logger().info(f"Speaking: {message}")

        # Publish to speech topic
        speech_msg = String()
        speech_msg.data = message
        self.speech_pub.publish(speech_msg)

        # Simulate speech duration
        time.sleep(len(message) * 0.05)  # ~50ms per character

        return ActionResult(
            action_type='speak',
            status=ExecutionStatus.COMPLETED,
            message=f"Said: {message}",
            duration=0.0,
            output={'message': message}
        )

    def _execute_wait(self, action: Dict) -> ActionResult:
        """Execute wait action."""
        params = action.get('parameters', {})
        duration = params.get('duration_seconds', 1.0)

        self.get_logger().info(f"Waiting: {duration}s")
        time.sleep(duration)

        return ActionResult(
            action_type='wait',
            status=ExecutionStatus.COMPLETED,
            message=f"Waited {duration}s",
            duration=duration
        )

    def _execute_scan(self, action: Dict) -> ActionResult:
        """Execute environment scan action."""
        params = action.get('parameters', {})
        scan_type = params.get('scan_type', 'quick')

        self.get_logger().info(f"Scanning environment: {scan_type}")

        # Simulate scanning by rotating
        twist = Twist()
        twist.angular.z = 0.5  # Rotate
        self.cmd_vel_pub.publish(twist)

        time.sleep(2.0 if scan_type == 'quick' else 5.0)

        # Stop rotation
        twist = Twist()
        self.cmd_vel_pub.publish(twist)

        # Simulate detected objects
        detected_objects = [
            {'type': 'cup', 'position': [1.0, 0.5, 0.8]},
            {'type': 'book', 'position': [2.0, -0.3, 0.9]},
        ]

        return ActionResult(
            action_type='scan',
            status=ExecutionStatus.COMPLETED,
            message=f"Scan complete: found {len(detected_objects)} objects",
            duration=0.0,
            output={'objects': detected_objects}
        )

    def cancel_execution(self):
        """Request cancellation of current execution."""
        if self.is_executing:
            self.get_logger().info("Cancellation requested")
            self.cancel_requested = True


def main(args=None):
    """Demo the action executor."""
    rclpy.init(args=args)

    print("\n" + "=" * 60)
    print("Action Executor Demo")
    print("=" * 60 + "\n")

    try:
        executor = ActionExecutor()

        # Demo plan
        demo_plan = {
            "goal": "Pick up the red cup",
            "plan": [
                {"step": 1, "type": "navigate", "target": "table",
                 "parameters": {"location_name": "table"},
                 "description": "Move to the table",
                 "estimated_duration": 5.0},
                {"step": 2, "type": "detect", "target": "red cup",
                 "parameters": {"object_type": "cup", "color": "red"},
                 "description": "Locate the red cup",
                 "estimated_duration": 2.0},
                {"step": 3, "type": "grasp", "target": "red cup",
                 "parameters": {"gripper_force": 0.5},
                 "description": "Grasp the red cup",
                 "estimated_duration": 3.0},
                {"step": 4, "type": "speak", "target": "user",
                 "parameters": {"message": "I have picked up the red cup"},
                 "description": "Announce completion",
                 "estimated_duration": 2.0}
            ],
            "total_estimated_time": 12.0,
            "confidence": 0.95
        }

        print("Executing demo plan...")
        print(f"Goal: {demo_plan['goal']}\n")

        results = executor.execute_plan(demo_plan)

        print("\n" + "=" * 60)
        print("Execution Results")
        print("=" * 60)
        for i, result in enumerate(results):
            print(f"Step {i+1}: {result.action_type} - {result.status.value}")
            print(f"  Message: {result.message}")
            print(f"  Duration: {result.duration:.2f}s")

        print("\nDemo complete.")

        # Keep node running for a moment
        rclpy.spin_once(executor, timeout_sec=1.0)

    except KeyboardInterrupt:
        print("\nShutdown requested")
    finally:
        if 'executor' in locals():
            executor.destroy_node()
        rclpy.shutdown()


if __name__ == "__main__":
    main()
